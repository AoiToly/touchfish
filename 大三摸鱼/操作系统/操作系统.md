# 1.1 操作系统的应用 

操作系统的定义：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各作业进行调度，以及方便用户使用的程序的集合

## 目标

方便：方便用户使用

有效：提高系统的资源利用率；提高系统的吞吐量

可扩充性：适用硬件、体系结构、应用的发展需求；误解偶->模块化->层次结构->面向对象

开放性：遵循国际标准，以实现兼容性

## 作用

用户与计算机硬件系统之间的接口

计算机系统资源的管理者

实现对计算机资源的抽象

## 推动OS发展的动力

不断提高计算机资源利用率

方便用户

器件的不断更新

计算机体系结构的不断发展

不断提出新的应用需求

# 1.2 操作系统的发展过程 

## 人工操作方式

用户独占全机

CPU等待人工操作

## 脱机输入输出方式

解决问题：人机矛盾、CPU和I/O设备之间速度不匹配

减少CPU空闲时间

提高I/O速度

## 单道批处理系统

批处理系统旨在提高系统资源利用率和系统吞吐量

缺点：系统中的资源得不到充分利用

## 多道批处理系统

后备队列

### 优缺点

资源利用率高

系统吞吐量大

平均周转时间长

无交互能力

### 要解决的问题

处理机争用问题

内存分配和保护问题

I/O设备分配问题

文件的组织和管理问题

作业管理问题

用户与系统的接口问题

## 分时系统

主要动力：满足用户对人机交互的需求

用户需求：人机交互、共享主机

关键问题：及时接收、及时处理（作业直接进入内存、采用轮转运行方式）

特征1：多路性

特征2：独立性

特征3：及时性

特征4：交互性

## 实时系统

特征1-4同分时系统

特征5：可靠性

注意点：开始截止时间、完成截止时间、硬实时任务(HRT)、软实时任务(SRT)

## 微机系统

单用户单任务OS：只允许一个用户上机且只允许用户程序作为一个任务运行，CP/M、MS-DOS

单用户多任务OS：只允许一个用户上机但允许用户把程序分为若干个任务使它们并发执行

多用户多任务OS：允许多个用户通过各自的终端，使用同一台机器，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发执行，从而可进一步提高资源利用率和系统吞吐量，UNIX OS

# 1.3 操作系统的基本特性

## 并发

## 共享

互斥共享

同时访问

## 虚拟

互斥共享技术

​	虚拟处理机技术

​	虚拟设备技术

空分复用技术

## 异步

进程以人们不可预知的顺序推进，但是无论以何种顺序推进，结构都相同

# 1.4 操作系统的主要功能

## 处理机管理

### 进程控制

创建

撤销

状态转换

### 进程同步

#### 同步机制

互斥

同步

锁-信号

临界资源

### 进程通信

管道

消息队列

### 调度

作业调度

进程调度

## 存储器管理

主要任务：为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存

### 内存分配

主要任务：为每道程序分配内存空间、提高存储器的利用率、允许正在运行的程序申请附加的内存空间

静态分配

动态分配

### 内存保护

主要任务：1、确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。2、绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行

### 地址映射

### 内存扩充

请求调入功能

置换功能

## 设备管理

主要任务：

1、完成用户进程提供的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作

2、提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备

### 缓冲管理

缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量

### 设备分配

### 设备处理

驱动

实现CPU和设备控制器之间的通信

## 文件管理

主要任务：对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性

### 文件存储空间管理

为每个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存、取速度

### 目录管理

为每个文件建立目录项，并对众多的目录项有效组织，以实现方便的按名存取

### 文件的读写管/理和保护

文件保护：防止未经核准的用户存取文件、防止冒名顶替存取文件、防止以不正确的方式使用文件

### 操作系统与用户之间的接口

![image-20211121162225300](操作系统.assets/image-20211121162225300.png)

#### 用户接口

联机用户接口

脱机用户接口

图形用户接口

#### 程序接口

### 现代操作系统的新功能

#### 系统安全

认证技术

密码技术

访问控制技术

反病毒技术

#### 网络功能和服务

网络通信

资源管理

应用互操作

#### 支持多媒体

接纳控制功能

实时调度

多媒体文件的存储

# 1.5 操作系统的结构设计

## 传统操作系统结构

无结构操作系统

模块化操作系统

​	优点：

​		提高了OS设计的正确性、可理解性和可维护性

​		容易扩充，增强了OS的可适应性

​		加速了OS的开发过程

​	缺点

​		模块及接口划分较困难

​		从功能上划分模块，未区别共享资源和独占资源

​		由于管理的差异，使OS结构变得不够清晰

分层结构操作系统

​	优点：

​		功能明确，调用关系清晰（高层对低层单向依赖），有利于**保证设计和实现的正确性**

​		低层和高层可分别实现（**便于扩充和维护**）；高层错误不会影响到低层；避免递归调用

​	缺点：

​		**系统效率降低**，各系统对具体划分多少层次有不同的看法。

## 内核

在CPU设计和生产的时候就划分了特权指令和非特权指令

应用程序只能使用非特权指令，如加法指令、减法指令

内核程序可以执行特权指令，如内存清零指令

特权指令只能由操作系统内核来使用

CPU 有两种状态，**“内核态”**和**“用户态”** （在CPU程序状态字寄存器PSW中存储）

处于**内核态时**，说明此时正在运行的是内核程序，此时可以执行**特权指令** 

处于**用户态时**，说明此时正在运行的是应用程序，此时只能执行**非特权指令**

![image-20211121155241687](操作系统.assets/image-20211121155241687.png)

**内核**是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是**内核程序**。

注意：操作系统内核需要运行在**内核态**
操作系统的非内核功能运行在**用户态**

## 客户/服务器模式

优点

​	数据分布处理和存储、便于集中管理、灵活性和可扩充性、易于改编应用软件

缺点

​	不可靠性和瓶颈问题、各模块与微内核间通过通信机制交互，系统运行效率较低

## 面向对象程序设计

## 微内核OS结构

### 优点

增强了操作系统的可扩展性

增强了系统的可靠性

可移植性强

提供了对分布式系统的支持

融入了面向对象技术

### 存在问题#

内核态与用户态频繁切换，导致运行效率有所降低

## 操作行动的体系结构

### 运行机制

#### 两种指令

特权指令	如：内存清零指令

非特权指令	如：普通的运算指令

#### 两种处理器状态

核心态#

用户态

#### 两种程序

内核程序

应用程序

### 操作系统内核

![image-20211121161219150](操作系统.assets/image-20211121161219150.png)

#### 时钟管理

实现计时功能

#### 中断处理

负责实现中断机制

#### 原语

是一种特殊的程序

处于操作系统最底层，是最接近硬件的部分

这种程序的运行具有原子性——其运行只能一气呵成，不可中断

运行时间较短，调用频繁

#### 对系统资源进行管理的功能

进程管理

存储器管理

设备管理

![image-20211121161236992](操作系统.assets/image-20211121161236992.png)

## 中断

![image-20211121161247400](操作系统.assets/image-20211121161247400.png)

CPU 上会运行两种程序，一种是**操作系统内核程序**，一种是应用程序

“中断”是让操作系统内核夺回CPU使用权的**唯一途径**

如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序

中断”会使CPU由**用户态**变为**内核态**，使操作系统重新夺回对CPU的控制权

内中断：与当前执行的指令有关， 中断信号来源于CPU内部

​	如除法指令除数为0、陷入指令（应用程序请求操作系统服务）

外中断：与当前执行的指令无关， 中断信号来源于CPU外部

​	如始终不见每30ms发送一个时钟中断信号

![image-20211121162122531](操作系统.assets/image-20211121162122531.png)

![image-20211121162154377](操作系统.assets/image-20211121162154377.png)

## 系统调用

![image-20211121162312288](操作系统.assets/image-20211121162312288.png)

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是**与共享资源有关的操作（如存储分配、I/O操作、文件管理等）**，都必须通过系统调用的方式向操作系统内核提 出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

# 2.1 程序

## 前趋图

## 程序顺序执行特征

顺序性

封闭性

可再现性

## 程序并发执行特征

间断性

失去封闭性

不可再现性

# 2.2 进程的描述

## 定义

程序关于某个数据集合的一次执行过程

## 组成部分(PCB+程序段+数据段)

## 特征

动态性

并发性

独立性

异步性

## 状态

### 就绪、执行、堵塞

<img src="操作系统.assets/image-20211122132938642.png" alt="image-20211122132938642" style="zoom:50%;" />

### 挂起原语

引起挂起状态的原因：
	终端用户的请求
	父进程请求
	负荷调节的需要
	操作系统的需要  

### PCB的作用

### PCB中的信息

#### 进程标识符

内部标识符

外部标识符

#### 处理机状态

通用寄存器

指令计数器

程序状态字PSW

用户栈指针

#### 进程调度信息

进程状态

进程优先级

进程调度算法

事件：进程变为堵塞态的事件

#### 进程控制信息

程序和数据地址

进程同步和通信机制

资源清单

### PCB的组织方式

线性方式

链接方式

索引方式

<img src="操作系统.assets/image-20211122133547810.png" alt="image-20211122133547810" style="zoom:50%;" />

# 2.3 进程控制

进程的创建

进程的终止

进程的堵塞与唤醒

进程的挂起与激活

无论哪个进程控制原语， 要做的无非三类事情：
	更新PCB中的信息
		a. 所有的进程控制原语一定都会修改进程状态标志
		b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
		c. 某进程开始运行前必然要恢复其运行环境
	将PCB插入合适的队列
	分配/回收资源  

# 2.4-2.5 进程同步

## 两种制约方式

间接制约方式

直接制约方式

## 临界资源

<img src="操作系统.assets/image-20211122140209517.png" alt="image-20211122140209517" style="zoom:50%;" />

## 临界区

进程访问临界资源的**代码段**

## 同步规则

 **空闲让进、忙则等待、有限等待、让权等待**

## 硬件同步机制

关中断

test-and-set指令：测试指令

Swap指令：交换指令

<img src="操作系统.assets/image-20211122141413327.png" alt="image-20211122141413327" style="zoom:50%;" />

## 信号量机制

### 分类

整形信号量

记录型信号量：满足忙则等待

AND型信号量

信号量集

​	Swait(S, d, d)， 只有一个信号量S， 允许每次申请d个资源，若现有资源数少于d， 不予分配
​	Swait(S, 1, 1)， 蜕化为一般的记录型信号量(S>1时)或互斥信号量(S=1时)
​	Swait(S, 1, 0)， 当S>=1时， 允许多个进程进入某特定区， 当S变为0后， 阻止任何进程进入特定区， 相当于可控开关  

### 应用

进程互斥

实现前驱关系

## 管程机制

## 经典进程同步问题

生产者-消费者问题

哲学家进餐问题

读者-写者问题

**行人过桥问题**

# 2.6 进程通信

## 进程通信的类型

低级通信，进程间仅交换一些状态和少量数据。 如： 进程之间的互斥和同步
	信号量机制作为通信工具的缺点：	(1)效率低 (2)通信对用户不透明
	共享某些数据结构或共享存储区

高级通信： 进程间可交换大量数据，对用户透明
	共享存储器系统、 消息传递系统、 管道通信系统、 客户机-服务器

### 共享存储器系统

基于共享数据结构的通信方式

基于共享存储区的通信方式

### 管道通信系统

只能实现单向的传输

各进程要互斥地访问管道

数据以字符流的形式写入管道， 当管道写满时， 写进程的write()系统调用将被阻塞， 等待读进程将数据取走。 当读进程将数据全部取走后， 管道变空， 此时读进程的read()系统调用将被阻塞。

如果没写完， 就不允许读。 如果没读空， 就不允许写。

数据一旦被读出， 就从管道中被抛弃， 这就意味着读进程最多只能有一个

### 消息传递系统

直接通信方式

间接通信方式：信箱通信

### 客户端-服务器系统

套接字

远程过程与方法调用

## 消息传递通信的实现方式

### 直接消息传递系统

对称寻址方式

非对称寻址方式

### 邮箱通信

信箱通信

# 2.7-2.8 线程

## 调度单位

## 不是资源拥有单位

## 进程与线程的比较

|            | 调度的基本单位 |  并发性   |           拥有资源           | 独立性 | 系统开销 | 多处理机 |
| :--------: | :------------: | :-------: | :--------------------------: | :----: | :------: | :------: |
| 无线程的OS |      进程      |     √     |         以进程为单位         | 进程高 |    大    |  不支持  |
| 有线程的OS |      线程      | 进程+线程 | 线程仅拥有必不可少的部分资源 | 线程低 |    小    |   支持   |

## 线程的实现

内核支持线程KST

用户级线程

组合方式及对应关系：一对一、多对一、多对多

## 线程的实现

内核支持线程KST

用户级线程

组合方式及对应关系：一对一、多对一、多对多

# 3.1 处理机调度的层次和目标

作业：外存->内存

## 处理机调度的层次

高级调度(作业调度、长程调度)

中级调度(内存调度，挂起+激活)

低级调度(进程调度、短程调度)

|                       |                           要做什么                           | 调度发生在.. | 发生 频率 |            对进程状态的影响             |
| :-------------------: | :----------------------------------------------------------: | :----------: | :-------: | :-------------------------------------: |
| 高级调度 （作业调度） | 按照某种规则，从后备队列中 选择合适的作业将其调入内存，并为其创建进程 |  外存→内存   |   最低    |            无→创建态→就绪态             |
| 中级调度 （内存调度） |   按照某种规则，从挂起队列中选择合适的进程将其数据调回内存   |  外存→内存   |   中等    | 禁止就绪→活动就绪 （禁止阻塞→活动阻塞） |
| 低级调度 （进程调度） |    按照某种规则，从就绪队列中 选择一个进程为其分配处理机     |   内存→CPU   |   最高    |              就绪态→运行态              |

## 处理机调度目标

### 共同目标

提高资源利用率

公平性(面向进程)

平衡性(面向设备)

策略强制执行

### 批处理OS的目标

平均周转时间短：在后备队列上的时间+在就绪队列的时间+在CPU的时间+等待I/O完成的时间

系统吞吐量高

处理机利用率高

### 分时系统目标

响应时间快

均衡性

### 实时系统目标

截止时间保证

可预测性

# 3.2 作业与作业调度（早期批处理系统）

## 先来先服务FCFS

| 算法思想           | 主要从“公平” 的角度考虑（类似于我们生活中排队买东西的例子）  |
| ------------------ | ------------------------------------------------------------ |
| 算法规则           | 按照作业/进程到达的先后顺序进行服务                          |
| 用于作业/进 程调度 | 用于作业调度时， 考虑的是哪个作业先到达后备队列； 用于进程调度 时， 考虑的是哪个进程先到达就绪队列 |
| 是否可抢占？       | 非抢占式的算法                                               |
| 优缺点             | 优点： 公平、 算法实现简单 缺点： 排在长作业（进程） 后面的短作业 需要等待很长时 间， 带权周转时间很大， 对短作业来说用户体验不好。 即， FCFS算法对长作业有利， 对短作业不利（Eg ： 排队买奶茶…） |
| 是否会导致 饥饿    | 不会                                                         |

## 短作业优先SJF

| 算法思想           | 追求最少的平均等待时间， 最少的平均周转时间、 最少的平均带权周转时间 |
| ------------------ | ------------------------------------------------------------ |
| 算法规则           | 最短的作业/进程优先得到服务（所谓“最短” ， 是指**要求服务时间最短** |
| 用于作业/进 程调度 | 即可用于作业调度， 也可用于进程调度。 用于进程调度时称为“短进程 优先（**SPF**, Shortest Process First） 算法” |
| 是否可抢占？       | SJF和SPF是**非抢占式**的算法。 但是也有抢占式的版本——**最短剩余时 间优先算法**（SRTN, Shortest Remaining Time Next） ， **默认非抢占式** |
| 优缺点             | 优点： “最短的” **平均等待时间、 平均周转时间** <br />缺点： 不公平。 **对短作业有利， 对长作业不利**。 可能产生饥饿现象。 |
| 是否会导致 饥饿    | 会。 如果源源不断地有短作业/进程到来， 可能使长作业/进程长时间得不 到服务， 产生“**饥饿**” 现象。 如果一直得不到服务， 则称为“**饿死**” |

## 优先级调度算法

Priority-Scheduling Algorithm, PSA

外部赋予

## 高相应比优先调度算法

Highest Response Ratio Next, HRRN

优先权 = (等待服务时间 + 要求服务时间) / 要求服务时间

| 算法思想          | 要综合考虑作业/进程的等待时间和要求服务的时间                |
| ----------------- | ------------------------------------------------------------ |
| 算法规则          | 在每次调度时先计算各个作业/进程的**响应比**，选择**响应比最高**的作业/进程为其服务 |
| 用于作业/进程调度 | 即可用于作业调度，也可用于进程调度。                         |
| 是否可抢占？      | **非抢占式**的算法。 因此只有当前运行的作业/进程**主动放弃处理机**时，才需要调度，才需要计算响应比 |
| 优缺点            | 综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF的优点） 要求服务时间相同时， 等待时间长的优先（FCFS 的优点） 对于长作业来说， 随着等待时间越来越久， 其响应比也会 越来越大， 从而避免了长作业饥饿的问题 |
| 是否会导致饥饿    | 不会                                                         |

<img src="操作系统.assets/image-20211122202818695.png" alt="image-20211122202818695" style="zoom:50%;" />

# 3.3 进程调度（交互式系统）

### 轮转调度算法	Round Robin, RR

| 算法思想           | 公平地、 轮流地为各个进程服务， 让每个进程在一定时间间隔得到内都可以响应 |
| ------------------ | ------------------------------------------------------------ |
| 算法规则           | 按照各进程到达就绪队列的顺序， 轮流让各个进程执行**一个时间片**（如 100ms） 。 若进程未在一个时间片内执行完， 则剥夺处理机， 将进程重 新放到就绪队列队尾重新排队。 |
| 用于作业/进 程调度 | 用于**进程调度**（只有作业放入内存建立了相应的进程后， 才能被分配处 理机时间片） |
| 是否可抢占？       | 若进程未能在时间片内运行完， 将被强行剥夺处理机使用权， 因此时间 片轮转调度算法属于**抢占式的算法**。 由时钟装置发出时钟中断来通知 CPU时间片已到 |
| 优缺点             | 优点： 公平； 响应快， 适用于分时操作系统； 缺点： 由于高频率的进程切换， 因此有一定开销； 不区分任务的紧急程 度。 |
| 是否会导致 饥饿    | 不会                                                         |

### 优先级调度算法

此算法常用于**批处理系统**中， 作为**作业调度算法**。 也作为多种操作系统中的**进程调度算法**， 还可用于**实时系统**中。

两种占用CPU的方式：**非抢占式优先级算法**， **抢占式优先级算法**

**非抢占式优先级算法**：主要用于**批处理系统**

**抢占式优先级算法**：优点： 能更好的满足**紧迫作业**的要求。 主要用于比较严格的**实时系统**

**优先级类型**：

​	**静态优先级**：在进程创建时确定的， 在进程整个运行期间保持不变

​	**优先级**： 利用某一范围的整数来表示， 该整数称为优先数。 如：0—7， 0—255

​	**确定优先级的依据**：进程类型、进程对资源的需求、用户要求

| 算法思想           | 随着计算机的发展， 特别是实时操作系统的出现， 越来越多的应用场景需要根据任务的紧急程度来决定处理顺序 |
| ------------------ | ------------------------------------------------------------ |
| 算法规则           | 调度时选择**优先级最高**的作业/进程                          |
| 用于作业/进 程调度 | 既可用于作业调度， 也可用于进程调度。 甚至， 还会用于在之后会学习 的I/O调度中 |
| 是否可抢占？       | **抢占式、 非抢占式**都有。 做题时的区别在于： 非抢占式只需在进程主动 放弃处理机时进行调度即可， 而抢占式还需在就绪队列变化时， 检查是 否会发生抢占。 |
| 优缺点             | 优点： 用优先级区分紧急程度、 重要程度， 适用于实时操作系统。 可灵 活地调整对各种作业/进程的偏好程度。 缺点： 若源源不断地有高优先级进程到来， 则可能导致饥饿 |
| 是否会导致 饥饿    | 会                                                           |

### 多队列调度算法

### 多级反馈队列调度算法	Multileved Feedback Queue

| 算法思想          | 对其他调度算法的折中权衡                                     |
| ----------------- | ------------------------------------------------------------ |
| 算法规则          | 1. 设置多级就绪队列， 各级队列优先级从高到低， 时间片从小到大 <br />2. 新进程到达时先进入第1级队列， 按FCFS原则排队等待被分配时间片若用完时间片进程还未结束， 则进程进入下一级队列队尾。 如果此时已经是在最下级的队列， 则重新放回该队列队尾 <br />3. 只有第 k 级队列为空时， 才会为 k+1 级队头的进程分配时间片 |
| 用于作业/进程调度 | 用于进程调度                                                 |
| 是否可抢占？      | **抢占式**的算法。 新进程可抢占低级进程的处理机              |
| 优缺点            | 对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点） |
| 是否会导致饥饿    | 会                                                           |

<img src="操作系统.assets/image-20211122204803811.png" alt="image-20211122204803811" style="zoom:50%;" />

### 基于公平原则的调度算法

# 3.4 实时调度

最早截止时间优先算法	Earliest Deadline First, EDF

最低松弛度优先算法	Least Laxity First, LLF

优先级倒置问题	优先级继承

# 3.5 死锁概述

## 死锁的定义

一组进程死锁指：进程所等待的事件是该组中其他进程释放所占有的资源

<img src="操作系统.assets/image-20211122205032791.png" alt="image-20211122205032791" style="zoom:50%;" />

## 产生死锁的原因

竞争不可抢占资源

竞争可消耗性资源

进程推进顺序不当：进程异步性特征

## 处理死锁的必要条件

互斥：只有对必须互斥使用的资源的争抢才会导致死锁

请求和保持：进程已经保持了至少一个资源， 但又提出了新的资源请求， 而该资源又被其他进程占有， 此时请求进程被阻塞， 但又对自己已有的资源保持不放

不可抢占：进程所获得的资源在未使用完之前， 不能由其他进程强行夺走， 只能主动释放。

循环等待/环路等待：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。
	注意！ 发生死锁时一定有循环等待， 但是发生循环等待时未必死锁  

## 处理死锁的方法

### 预防死锁

#### 互斥条件是由设备**固有条件**所决定的，应加以保证，不可破坏

#### 破坏“请求和保持”

第一种协议： 即进程在运行前一次申请完它所需要的全部资源， 在它的资源未满足前， 不让它投入运行。 一旦投入运行后， 这些资源就一直归它所有， 该进程就不会再请求别的任何资源了。

优点： 算法简单、 易于实现且很安全。 缺点： 资源浪费严重和进程延容易

第二种协议： 允许进程只获得运行初期所需的资源， 便开始运行。 运行过程中再逐步释放已分配给自己的资源及已用毕的资源， 然后再请求新的资源。

优点： 提高设备利用率， 减少进程发生饥饿的概率。  

#### 破坏“不可抢占”

破坏不可抢占条件： 当某个进程请求新的资源得不到满足时， 它必须立即释放保持的所有资源， 待以后需要时再重新申请。  

缺点：

1. 实现起来比较复杂。
2. 释放已获得的资源可能造成前一阶段工作的**失效**。 因此这种方法一般只适用于易保存和恢复状态的资源， 如CPU。
3. 反复地申请和释放资源会**增加系统开销**， 降低**系统吞吐量**。
4. 意味着只要暂时得不到某个资源， 之前获得的那些资源就都需要放弃， 以后再重新申请。 如果一直发生这样的情况， 就会导致进程**饥饿**。  

#### 破坏“循环等待”

顺序资源分配法  

### 避免死锁

安全状态

银行家算法

### 检测死锁

资源分配图，能完全简化则无死锁

### 解除死锁

以最小代价终止进程，解除死锁

剥夺资源、撤销进程







# 第4章 存储器管理

## 4.1 存储器的层次结构

### 4.1.1 多级存储器结构

存储层次至少应有三级：**CPU寄存器**、**主存**、**辅存**

![image-20211203081235616](操作系统.assets/image-20211203081235616.png)

### 4.1.2 主存储器与寄存器（可执行存储器）

1. 主存储器

​	CPU可从其中取指令和数据，数据能从主存读取并装入到寄存器中，或从寄存器存入到主存。用于保存进程运行时的程序和数据。

2. 寄存器

​	寄存器访问速度最快，与处理机相同。其长度以字为单位。

### 4.1.3 高速缓存和磁盘缓存

1. 高速缓存（cache)

​	容量大于寄存器，访问速度快于内存。

​	Cache分类：

​		一级cache紧靠内存，速度最高，容量最小。

​		二级cache容量稍大，速度也稍低。

2. 磁盘缓存

​	目的：为了缓和磁盘的I/O速度和主存的访问速度的不匹配，暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数

​	磁盘缓存本身并不是一种实际存储介质。

​	实质：利用主存中的存储空间，来暂存从磁盘中读出或写入的信息

### 4.2 程序的装入和链接

用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常要经过以下几个步骤：编译、链接、装入

![image-20211203084447428](操作系统.assets/image-20211203084447428.png)

![image-20211203090827395](操作系统.assets/image-20211203090827395.png)

**物理地址**：物理内存的地址，内存以字节为单位编址，物理地址空间是所有物理地址的集合

**逻辑地址（虚拟地址）**：程序编译后使用的相对于0字节的地址。逻辑地址空间是由程序锁生成的所有逻辑地址的集合

用大白话说：符号地址是用户视图，物理地址是计算机视图，逻辑地址是其中的转换视图

### 4.2.1 程序的装入

#### 1. 绝对装入方式

编译时产生的地址使用绝对地址

程序或数据被修改时，需要重新编译程序

只适用于单道程序环境

#### 2. 可重定位装入方式

编译后的目标模块使用相对地址

在装入时，完成**重定位**（静态重定位）

需硬件支持

**重定位**：逻辑地址转换为物理地址的过程，称为重定位，也称为地址变换

#### 3. 动态运行时的装入方式

编译后的目标模块使用相对地址

在运行时，完成重定位（动态重定位）

需要重定位寄存器

![image-20211203093413322](操作系统.assets/image-20211203093413322.png)

### 4.2.2 程序的链接

源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。

具体工作：对相对地址修改；变换外部调用符号

#### 1. 静态链接方式

在程序运行前，将各目标模块及它们所需的库函数链接成一个完整的模块，以后不再拆开

对相对地址进行修改；变换外部调用符号

#### 2. 装入时动态链接

在装入内存时，采用边装入边链接的链接方式

便于修改和更新

便于实现对目标模块的共享

#### 3. 运行时动态链接

将某些模块的链接推迟到执行时才执行。即在执行过程中，若发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将它装入内存，并把它链接到调用者模块上。

加快装入过程，节省大量内存空间

## 4.3 连续分配存储管理方式

为用户程序分配一个连续的内存空间，曾被广泛应用，且现在仍被采用。

### 4.3.1 单一连续分配

在单道程序环境下，仅装有一道用户程序，即整个内存的用户空间由该程序独占

### 4.3.2 固定分区分配

预先把可分配的主存空间分割成若干个连续的区域，称为一个分区

**划分分区的方法**：分区大小一样、分区大小不等

**内存分配管理**：

​	将分区按大小排队，一般由小到大

​	建立分区使用表——起址、大小、状态

​	程序装入时，由内存分配程序检索分区使用表，找到符合要求的分区，并进行标记。

![image-20211205152438930](操作系统.assets/image-20211205152438930.png)

### 4.3.3 动态分区分配

根据进程的实际需要，动态地分配内存空间

#### 1. 动态分区分配中的数据结构

空闲分区表：每个空闲分区占一个表目，表目中包括分区号、分区大小和分区始址等数据项

![image-20211205155320206](操作系统.assets/image-20211205155320206.png)

空闲分区链：双向链表

![image-20211205155659713](操作系统.assets/image-20211205155659713.png)

#### 2. 动态分区分配算法

4.3.4 - 4.3.5

#### 3. 分区分配操作

**分配内存**

从空闲分区链（表）中找到所需大小的分区。

判断条件：M.Size - U.Size ≦ Size

剩余部分挂接到空闲分区链（表）上。

![image-20211205183339657](操作系统.assets/image-20211205183339657.png)

**回收内存**

回收区与插入点的前一个空闲分区相邻接

回收区与插入点的后一个空闲分区相邻接

回收区与插入点的前后两个空闲分区相邻接

回收区不与任何一个空闲分区相邻接

![image-20211205183408673](操作系统.assets/image-20211205183408673.png)

### 4.3.4 基于顺序搜索的动态分区分配算法

**首次适应算法（First Fit, FF）**：

  空闲分区按起址递增次序排列，从头开始直至找到第一个满足要求的空闲分区。

  特点：内存低端会留下小的空闲区，高端有大的空闲区

**循环首次适应算法（Next Fit, NF）**：

  从上次分配的位置之后开始查找。

  特点：使内存的空闲分区均匀，但缺乏大的空闲分区

**最佳适应算法（Best Fit, BF）**：

  搜索整个序列，找到适合条件的最小的分区进行分配

  空闲分区按其容量从小到大的顺序链接

  用最小空间满足要求，但缺点明显会留下大量难以利用的小碎片。

**最坏适应算法（Worst Fit, WF）**：

  与BF正好相反，空闲分区按大小从大到小的次序排列，最前面的最大的空闲分区就是找到的分区。

  优点：分割后空闲块仍为较大空块

  缺点：一段时间后就不能满足对于较大空闲区的分配要求。

### 4.3.5 基于索引搜索的动态分区分配算法

**快速适应算法（Quick Fit）**：

  空闲分区按容量大小进行分类。

  对于每一类具有相同容量的所有空闲空间分区，单独设立一个空闲分区链表。

  在内存中设立一张管理索引表，每个表项对应一种空闲分区类型。

  优点：不分割分区，不产生碎片，查找效率高

  缺点：分区归还主存时算法复杂。系统开销大，存在浪费**

**伙伴系统（Bubby system）**：

分区（已分配和空闲）大小均为2的k次幂（1<=k<=m), $2^m$为可分配内存大小。

对不连续的空闲分区，按分区大小进行分类。对具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，即会存在k个空闲分区链表。

分配时，设需分配长度为n，找$2^i$分区链的分区，使$2^{i-1}<n<2^i$，若无，找$2^{i+1}$且把它均分两块，称为伙伴。一个加入$2^i$分区链，一个分配；.......

回收时，若已存在$2^i$空闲分区，则将其于伙伴合并为$2^{i+1}$分区，.....

特点：性能取决于查找空闲分区的位置和分割、合并的时间。 时间上不及快速适应算法，但空闲分区的使用率高

![image-20211205184852165](操作系统.assets/image-20211205184852165.png)

**哈希算法**：

利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数。

构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表。

分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，找到对应的空闲分区表。

优点：查找快速

### 4.3.6 可重定位分区分配

随着系统接收的作业的增加，内存中连续的大块分区不复存在，产生了大量的“碎片”。

新的作业无法装入到每个“碎片”小分区上运行，但所有碎片的空间总和可能大于需求。

紧凑：通过移动内存中进程位置，一把原来多个分散的小分区拼接成一个大分区的方法，也叫作 “拼接”。

动态重定位：在指令运行时，实现地址转换（从相对地址转换为绝对地址）

分配算法：类似于动态分区分配，增加了紧凑的功能。
